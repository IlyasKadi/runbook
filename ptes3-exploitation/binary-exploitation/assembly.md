# assembly

## RAM

Random Access Memory (RAM) is made up of four parts.

| Segment | Description                                                                                                                                                             |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Stack   | The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory.                                                           |
| Heap    | Heap is the segment where dynamic memory allocation usually takes place. The heap area begins at the end of the BSS segment and grows to larger addresses from there.   |
| Data    | A data segment is a portion of the virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer. |
| Text    | A text segment is one of the sections of a program in an object file or in memory, which contains executable instructions.                                              |

## Registers

A processor register is a quickly accessible location available to a computer's processor. There are two main types of registers.

- _Data registers_: Usually used for storing instructions / syscall arguments.
- _Pointer registers_: Store address pointers. The main pointer registers are the base stack pointer `rbp`, which points to the beginning of the stack, the current stack pointer `rsp`, which points to the top of the stack, and the instruction pointer `rip`, which holds the address of the next instruction.

| Data registers | Pointer registers |
|----------------|-------------------|
| rax            | rbp               |
| rbx            | rsp               |
| rcx            | rip               |
| rdx            |                   |
| r8 / r9 / r10  |                   |

## Hello world

Hello world! Looks in Assembly as follows (`helloWorld.s`).

```assembly
global  _start

section .data
    message db "Hello World!", 0x0a
    length  equ $-message

section .text
_start:
         mov     rax, 1
         mov     rdi, 1
         mov     rsi, message
         mov     rdx, 18
         syscall

         mov     rax, 60
         mov     rdi, 0
         syscall
```

- The `global _start` directive directs the code to start executing instructions at the `_start` label.
- The `section .data` contains the global variables.
- The `section .text` contains the code to be executed.

### Assembling

Run the code using the following steps
- Assemble the file using

```shell
nasm -f elf64 helloWorld.s
```
- Link the file into an Executable and Linkable Format (elf) file using
```shell
ld -o helloWorld helloWorld.o
```

### Disassembling
To dissasemble an elf executable file, run

```shell
objdump -M intel -d helloWorld
```

To dump the strings run
```shell
objdump -s helloWorld
```

## GDB

A well known Linux debugger is [GDB](https://www.sourceware.org/gdb/). A nice plugin for exploit dev and reversing if [GEF (GDB Enhanced Features)](https://github.com/hugsy/gef).

Start the debugger using

```shell
gdb -q helloWorld
```

Useful commands are listed below
- `info functions` - display the functions defined in the binary
- `info variables` - display the variables defined in the binary
- `disassemble _start` - view instruction set
- `b _start` - set breakpoint at start of program
- `run` or `r` - run program from start
- `continue` or `c` - continue program
- `stepi` or `si` - continue 1 step in the program
- `step` or `s` - continue until function exit
- `x/s addr` - examine the value of a variable at address `addr`

## Instructions

| Instruction | Description    | Example                                 |
|-------------|----------------|-----------------------------------------|
| mov         | Move/load data | mov rax, 1 => rax = 1                   |
| lea         | Load address   | lea rax, [rsp+5] => rax = rsp + 5       |
| xchg        | Swap data      | xchg rax, rbx => rax := rbx, rbx := rax |
| inc         | Increment by 1 | inc rax => rax++                        |
| dec         | Decrement by 1 | dec rax => rax--                        |
| add         | Add            | add rax, rbx => rax += rbx              |
| sub         | Subtract       | sub rax, rbx => rax -= rbx              |
| imul        | Multiply       | imul rax, rbx => rax *= rbx             |
| not         | Bitwise not    | not rax => 01 -> 10                     |
