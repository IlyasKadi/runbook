# assembly

## RAM

Random Access Memory (RAM) is made up of four parts.

| Segment | Description                                                                                                                                                             |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Stack   | The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory.                                                           |
| Heap    | Heap is the segment where dynamic memory allocation usually takes place. The heap area begins at the end of the BSS segment and grows to larger addresses from there.   |
| Data    | A data segment is a portion of the virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer. |
| Text    | A text segment is one of the sections of a program in an object file or in memory, which contains executable instructions.                                              |

## Registers

A processor register is a quickly accessible location available to a computer's processor. There are two main types of registers.

- _Data registers_: Usually used for storing instructions / syscall arguments.
- _Pointer registers_: Store address pointers. The main pointer registers are the base stack pointer `rbp`, which points to the beginning of the stack, the current stack pointer `rsp`, which points to the top of the stack, and the instruction pointer `rip`, which holds the address of the next instruction.

| Data registers | Pointer registers |
|----------------|-------------------|
| rax            | rbp               |
| rbx            | rsp               |
| rcx            | rip               |
| rdx            |                   |
| r8 / r9 / r10  |                   |

## Hello world

Hello world! Looks in Assembly as follows (`helloWorld.s`).

```assembly
global  _start

section .data
    message db "Hello World!", 0x0a
    length  equ $-message

section .text
_start:
         mov     rax, 1
         mov     rdi, 1
         mov     rsi, message
         mov     rdx, 18
         syscall

         mov     rax, 60
         mov     rdi, 0
         syscall
```

- The `global _start` directive directs the code to start executing instructions at the `_start` label.
- The `section .data` contains the global variables.
- The `section .text` contains the code to be executed.

### Assembling

Run the code using the following steps
- Assemble the file using

```shell
nasm -f elf64 helloWorld.s
```
- Link the file into an Executable and Linkable Format (elf) file using
```shell
ld -o helloWorld helloWorld.o
```

### Disassembling
To dissasemble an elf executable file, run

```shell
objdump -M intel -d helloWorld
```

To dump the strings run
```shell
objdump -s helloWorld
```

## GDB

A well known Linux debugger is [GDB](https://www.sourceware.org/gdb/). A nice plugin for exploit dev and reversing if [GEF (GDB Enhanced Features)](https://github.com/hugsy/gef).

Start the debugger using

```shell
gdb -q helloWorld
```
