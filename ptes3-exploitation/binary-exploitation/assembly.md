# assembly

## RAM

Random Access Memory (RAM) is made up of four parts.

| Segment | Description                                                                                                                                                             |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Stack   | The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory.                                                           |
| Heap    | Heap is the segment where dynamic memory allocation usually takes place. The heap area begins at the end of the BSS segment and grows to larger addresses from there.   |
| Data    | A data segment is a portion of the virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer. |
| Text    | A text segment is one of the sections of a program in an object file or in memory, which contains executable instructions.                                              |

## Registers

A processor register is a quickly accessible location available to a computer's processor. There are two main types of registers.

- _Data registers_: Usually used for storing instructions / syscall arguments.
- _Pointer registers_: Store address pointers. The main pointer registers are the base stack pointer `rbp`, which points to the beginning of the stack, the current stack pointer `rsp`, which points to the top of the stack, and the instruction pointer `rip`, which holds the address of the next instruction.

| Data registers | Pointer registers |
|----------------|-------------------|
| rax            | rbp               |
| rbx            | rsp               |
| rcx            | rip               |
| rdx            |                   |
| r8 / r9 / r10  |                   |

## Hello world

Hello world! Looks in Assembly as follows (`helloWorld.s`).

```assembly
global  _start

section .data
    message db "Hello World!", 0x0a
    length  equ $-message

section .text
_start:
         mov     rax, 1
         mov     rdi, 1
         mov     rsi, message
         mov     rdx, 18
         syscall

         mov     rax, 60
         mov     rdi, 0
         syscall
```

- The `global _start` directive directs the code to start executing instructions at the `_start` label.
- The `section .data` contains the global variables.
- The `section .text` contains the code to be executed.

### Assembling

Run the code using the following steps
- Assemble the file using

```shell
nasm -f elf64 helloWorld.s
```
- Link the file into an Executable and Linkable Format (elf) file using
```shell
ld -o helloWorld helloWorld.o
```

### Disassembling
To dissasemble an elf executable file, run

```shell
objdump -M intel -d helloWorld
```

To dump the strings run
```shell
objdump -s -j .data helloWorld
```

Or, as a script

```shell
#!/bin/bash
# assembler.sh

fileName="${1%%.*}" # remove .s extension

nasm -f elf64 ${fileName}".s"
ld ${fileName}".o" -o ${fileName}
[ "$2" == "-g" ] && gdb -q ${fileName} || ./${fileName}
```

## GDB

A well known Linux debugger is [GDB](https://www.sourceware.org/gdb/). A nice plugin for exploit dev and reversing if [GEF (GDB Enhanced Features)](https://github.com/hugsy/gef).

Start the debugger using

```shell
gdb -q helloWorld
```

Useful commands are listed below
- `info functions` - display the functions defined in the binary
- `info variables` - display the variables defined in the binary
- `disassemble _start` - view instruction set
- `b _start` - set breakpoint at start of program
- `run` or `r` - run program from start
- `continue` or `c` - continue program
- `stepi` or `si` - continue 1 step in the program
- `step` or `s` - continue until function exit

### Examining values

You can examine values in registers and addresses using

```shell
x/FMT ADDRESS
```
The `FMT` is made up of three parts
- Count - number of times to repeat the examine
- Format - the format to represent the result in, `x` (hex), `s` (string), `i` (instruction)
- Size - the size of the memory to examine, `b` (byte), `h` (halfword), `w` (word), `g` (giant, 8 bytes)

## Instructions

| Instruction | Description                                                           | Example                                 |
|-------------|-----------------------------------------------------------------------|-----------------------------------------|
| mov         | Move/load data                                                        | mov rax, 1 => rax = 1                   |
| lea         | Load address                                                          | lea rax, [rsp+5] => rax = rsp + 5       |
| xchg        | Swap data                                                             | xchg rax, rbx => rax := rbx, rbx := rax |
| inc         | Increment by 1                                                        | inc rax => rax++                        |
| dec         | Decrement by 1                                                        | dec rax => rax--                        |
| add         | Add                                                                   | add rax, rbx => rax += rbx              |
| sub         | Subtract                                                              | sub rax, rbx => rax -= rbx              |
| imul        | Multiply                                                              | imul rax, rbx => rax *= rbx             |
| not         | Bitwise not                                                           |                                         |
| and         | Bitwise and                                                           |                                         |
| or          | Bitwise or                                                            |                                         |
| xor         | Bitwise xor                                                           |                                         |
| push        | Copies address to top of stack                                        | push rax                                |
| pop         | Move item from top of stack to register                               | pop rax                                 |
| call        | Push next instruction pointer to rip to stack, then jump to procedure | call printMessage                       |
| ret         | Pop address at rsp to rip, then jump to it                            | ret                                     |

## Syscall

A syscall is a function written in C provided by the operating system kernel.
Let's look at one that writes something to the screen.

```shell
cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h | grep __NR_write
```

We can get more information on the syscall using

```shell
man -s 2 write
```

The syscall arguments are presented below

| Description                 | 64-bit register | 8-bit register |
|-----------------------------|-----------------|----------------|
| Syscall number/return value | rax             | al             |
| Callee saved                | rbx             | bl             |
| arg 1                       | rdi             | dil            |
| arg 2                       | rsi             | sil            |
| arg 3                       | rdx             | cl             |
| arg 4                       | rcx             | bpl            |

## Shellcode

Shellcode is the hexadecimal representation of a binary's executable machine code.

You can convert assembly code to machine code and vica versa using `pwntools`

```shell
pwn asm 'push rax' -c 'amd64'
```
```shell
pwn disasm '50' -c 'amd64'
```

You can extract a binary's shellcode using

```python
#!/usr/bin/python3
# shellcoder.py

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

file = ELF(sys.argv[1])
shellcode = file.section(".text")
print(shellcode.hex())
print("%d bytes - Found NULL byte" % len(shellcode)) if [i for i in shellcode if i == 0] else print("%d bytes - No NULL bytes" % len(shellcode))

```

We can run shellcode using

```python
#!/usr/bin/python3
# loader.py

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

run_shellcode(unhex(sys.argv[1])).interactive()
```

Finally, we can also create binary ELF file to debug using `gdb`

```python
#!/usr/bin/python3
# assembler.py

import sys, os, stat
from pwn import *

context(os="linux", arch="amd64", log_level="error")

ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
os.chmod(sys.argv[2], stat.S_IEXEC)
```

The requirements for binaries to give shellcode that can be loaded directly into memory are the following.
The assembly code must
- Not contain variables.
- Not refer to direct memory addresses.
- Not contain any null bytes `00`.

### Generating shellcode

- We can write shellcode ourselves
- We can generate shellcode using `msfvenom`
```shell
msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex'
```
- Shellcode for `/bin/sh` on `Linux/x86_64` can be found on [ExploitDB](https://www.exploit-db.com/shellcodes/47008).
